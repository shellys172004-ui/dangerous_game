<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Radiating Bars Test</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

<style>
*{margin:0;padding:0;box-sizing:border-box}
body{
  height:100vh;
  overflow:hidden;
  font-family:'Orbitron',sans-serif;
  background:radial-gradient(circle at top,#0e1a2f,#05070c);
  color:#00fff0;
}

/* BACKGROUND GRID */
.background{
  position:fixed;inset:0;
  background:
    repeating-linear-gradient(0deg,rgba(0,255,255,.06) 0 1px,transparent 1px 36px),
    repeating-linear-gradient(90deg,rgba(0,255,255,.06) 0 1px,transparent 1px 36px);
  animation:grid 12s linear infinite;
  z-index:0;
}
@keyframes grid{to{background-position:0 36px,36px 0}}

/* SPRINKLES */
.sprinkles{position:fixed;inset:0;pointer-events:none;z-index:1}
.sprinkle{
  position:absolute;
  width:4px;height:4px;
  background:#00fff0;
  box-shadow:0 0 12px #00fff0,0 0 30px #00fff0;
  animation:float 6s linear infinite;
}
@keyframes float{
  from{transform:translateY(100vh);opacity:0}
  to{transform:translateY(-10vh);opacity:1}
}

/* UI */
.ui{
  position:relative;
  z-index:3;
  height:100%;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
}
.ui.hidden{display:none}

h2{
  font-size:2.3rem;
  text-shadow:0 0 25px #00fff0;
  margin-bottom:20px;
  animation:floatQ 3s ease-in-out infinite;
}
@keyframes floatQ{50%{transform:translateY(-10px)}}

button{
  padding:14px 40px;
  margin:12px;
  font-family:'Orbitron';
  font-size:1rem;
  border-radius:10px;
  border:none;
  cursor:pointer;
}

/* YES */
#yes{
  background:linear-gradient(135deg,#00fff0,#00b3ff);
  color:#000;
  box-shadow:0 0 40px rgba(0,255,240,.35);
}

/* NO */
#no{
  background:#ff004c;
  color:#fff;
  box-shadow:0 0 35px rgba(255,0,76,.35);
}

/* wraps so canvases can follow */
.wrap{
  position:relative;
  display:inline-block;
}

/* Overlay */
.tapOverlay{
  position:fixed;
  inset:0;
  z-index:999;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#000;
  cursor:pointer;
}
.tapOverlay.hidden{display:none}

.overlayWrap{
  position:relative;
  display:inline-block;
  overflow:visible;
}

.tapOverlay span{
  padding:14px 18px;
  border:1px solid #00fff0;
  box-shadow:0 0 30px rgba(0,255,240,.55);
  border-radius:18px;
  text-shadow:0 0 18px #00fff0;
  color:#00fff0;
  position:relative;
  z-index:2;
  background:rgba(0,0,0,.15);
}

/* overlay scaling */
.tapOverlay.step1 span{ font-size:1.05rem; transform:scale(1); }
.tapOverlay.step2 span{ font-size:1.35rem; transform:scale(1.15); }
.tapOverlay.step3 span{ font-size:1.8rem;  transform:scale(1.35); }

/* small helper */
.hint{
  margin-top:18px;
  opacity:.7;
  font-size:.9rem;
}
</style>
</head>

<body>
<div class="background"></div>
<div class="sprinkles" id="sprinkles"></div>

<div class="ui" id="mainUI">
  <h2 id="question">Will you be my valentine?</h2>

  <div class="wrap" id="yesWrap">
    <button id="yes">YES</button>
  </div>

  <div class="wrap" id="noWrap">
    <button id="no">NO</button>
  </div>

  <div class="hint">(Test rig: overlay + radiating bars + audio envelope)</div>
</div>

<div class="tapOverlay step1" id="tapOverlay">
  <div class="overlayWrap" id="overlayWrap">
    <span id="tapOverlayText">Click if you really want to enter.</span>
  </div>
</div>

<audio id="questionSound" src="question.mp3" loop></audio>
<audio id="happySound" src="happy_happy_happy_cat.mp3"></audio>
<audio id="heartbeat" src="heartbeat.mp3" loop></audio>

<script>
/* SPRINKLES */
const sprinkles=document.getElementById('sprinkles');
for(let i=0;i<50;i++){
  const s=document.createElement('div');
  s.className='sprinkle';
  s.style.left=Math.random()*100+'%';
  s.style.animationDelay=Math.random()*6+'s';
  sprinkles.appendChild(s);
}

/* ELEMENTS */
const yes = document.getElementById('yes');
const no = document.getElementById('no');
const yesWrap = document.getElementById('yesWrap');
const noWrap = document.getElementById('noWrap');

const questionEl = document.getElementById('question');

const tapOverlay = document.getElementById('tapOverlay');
const overlayWrap = document.getElementById('overlayWrap');
const tapOverlayText = document.getElementById('tapOverlayText');

const questionSound = document.getElementById('questionSound');
const happySound = document.getElementById('happySound');
const heartbeat = document.getElementById('heartbeat');

questionSound.volume = 0.6;
happySound.volume = 1.0;
heartbeat.volume = 0.85;

/* ===================== AUDIO ANALYSER ===================== */
let audioCtx = null;
let analyser = null;
let dataArr = null;
let sources = new Map();
let currentAudioEl = null;

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  dataArr = new Uint8Array(analyser.frequencyBinCount);
  analyser.connect(audioCtx.destination);
}

function getSourceFor(el){
  if(sources.has(el)) return sources.get(el);
  const src = audioCtx.createMediaElementSource(el);
  sources.set(el, src);
  return src;
}

function setActiveAudio(el){
  if(!audioCtx || !analyser) return;
  if(currentAudioEl === el) return;

  if(currentAudioEl && sources.has(currentAudioEl)){
    try{ sources.get(currentAudioEl).disconnect(); }catch(e){}
  }
  currentAudioEl = el;

  try{
    const src = getSourceFor(el);
    src.connect(analyser);
  }catch(e){}
}

function getEnergy(){
  analyser.getByteFrequencyData(dataArr);

  // "glow-like" envelope (midband average)
  const start = 18;
  const end = Math.min(dataArr.length-1, 220);

  let sum=0, n=0;
  for(let i=start;i<=end;i++){ sum += dataArr[i]; n++; }
  let v = (sum/n)/255;  // 0..1
  v = v*v;              // curve, like your glow
  return v;
}
/* ========================================================== */

/* ===================== RADIATOR (YOUR SKETCH) ===================== */
/*
  We draw ultra-thin "hairline" bars emanating outward from the element outline.
  Key rules:
  - Mirror symmetry: bar i and bar (N-1-i) behave identically (same delayed envelope)
  - Delay increases as you move away from the center of a side
  - Corners get diagonal "blend" bars
*/

class Radiator {
  constructor(targetEl, color="#00fff0"){
    this.el = targetEl;
    this.color = color;

    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');

    this.canvas.style.position = 'fixed';
    this.canvas.style.left = '0';
    this.canvas.style.top = '0';
    this.canvas.style.pointerEvents = 'none';
    this.canvas.style.zIndex = '998'; // under overlay content but above bg

    document.body.appendChild(this.canvas);

    this.dpr = Math.max(1, window.devicePixelRatio || 1);

    this.lastRectKey = "";
    this.sides = null; // cached bar descriptors per side
    this.cornerBars = null;

    // delayed envelopes by "distance group"
    this.groupLevels = [];
  }

  destroy(){
    try{ this.canvas.remove(); }catch(e){}
  }

  _build(rect){
    // compute bar spacing so it never becomes a blob
    // smaller spacing => more bars, but we keep it reasonable
    const spacing = 6; // px between bars along edge (fine but visible)
    const inset = 2;   // how close to edge the bar base sits

    const w = rect.width;
    const h = rect.height;

    const topN = Math.max(18, Math.floor(w / spacing));
    const sideN = Math.max(14, Math.floor(h / spacing));

    const makeSide = (N, axisLen) => {
      // bars indexed 0..N-1, center at (N-1)/2
      const center = (N-1)/2;
      // groupCount is ceil(N/2), group 0 at center, larger toward ends
      const groupCount = Math.ceil(N/2);
      return { N, center, groupCount, axisLen };
    };

    this.sides = {
      top: makeSide(topN, w),
      bottom: makeSide(topN, w),
      left: makeSide(sideN, h),
      right: makeSide(sideN, h),
      inset
    };

    // maximum group count across sides -> allocate delayed levels
    const maxGroups = Math.max(
      this.sides.top.groupCount,
      this.sides.left.groupCount
    );
    this.groupLevels = new Array(maxGroups).fill(0);

    // corner blend bars (diagonals)
    // (small fan of bars, same "grouping" outward)
    const cornerFan = 9;
    this.cornerBars = { cornerFan };

    // resize canvas to viewport
    this.canvas.width = Math.floor(innerWidth * this.dpr);
    this.canvas.height = Math.floor(innerHeight * this.dpr);
    this.canvas.style.width = innerWidth + "px";
    this.canvas.style.height = innerHeight + "px";
    this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
  }

  _updateGroups(master){
    // master is 0..1
    // group 0 follows fastest; groups farther away lag more
    // we exaggerate the difference so it is OBVIOUS (your screenshot issue)
    for(let g=0; g<this.groupLevels.length; g++){
      const lag = Math.min(0.26, 0.06 + g * 0.028); // bigger g => more lag
      // attack faster than decay for punchy peaks
      const cur = this.groupLevels[g];
      const target = master;
      let next;
      if(target > cur){
        next = cur + (target - cur) * (0.55 - lag); // fast attack
      }else{
        next = cur + (target - cur) * (0.16 - lag*0.35); // slower decay
      }
      this.groupLevels[g] = Math.max(0, Math.min(1, next));
    }
  }

  _groupForIndex(i, N){
    // mirror-symmetric "distance from center" groups
    // i and N-1-i map to same group
    const center = (N-1)/2;
    const dist = Math.abs(i - center);
    // integer group: 0 near center, increasing outward
    return Math.floor(dist);
  }

  _drawBar(x1,y1, x2,y2, alpha=1){
    const c = this.ctx;
    c.globalAlpha = alpha;
    c.beginPath();
    c.moveTo(x1,y1);
    c.lineTo(x2,y2);
    c.stroke();
  }

  render(masterEnergy){
    const rect = this.el.getBoundingClientRect();
    if(rect.width < 5 || rect.height < 5) return;

    const key = `${Math.round(rect.left)}|${Math.round(rect.top)}|${Math.round(rect.width)}|${Math.round(rect.height)}|${Math.round(innerWidth)}|${Math.round(innerHeight)}|${this.dpr}`;
    if(key !== this.lastRectKey){
      this.lastRectKey = key;
      this._build(rect);
    }

    // Update delayed envelopes
    this._updateGroups(masterEnergy);

    const c = this.ctx;
    c.clearRect(0,0,innerWidth,innerHeight);

    const x0 = rect.left;
    const y0 = rect.top;
    const w = rect.width;
    const h = rect.height;

    // styling
    c.lineWidth = 1;
    c.strokeStyle = this.color;

    // glow-ish stroke (subtle)
    c.shadowColor = this.color;
    c.shadowBlur = 10;

    const inset = this.sides.inset;

    // exaggeration for length (you asked)
    const minLen = 3;
    const maxLen = 36;

    // helper to get side “weight curve” (stronger near center)
    function edgeWeight(t){
      // t 0..1, peak at center
      return 0.35 + 0.65*Math.sin(Math.PI*t);
    }

    // TOP
    {
      const {N} = this.sides.top;
      for(let i=0;i<N;i++){
        const t = i/(N-1);
        const gx = x0 + t*w;
        const gy = y0 + inset;

        const group = this._groupForIndex(i, N);
        const lvl = this.groupLevels[Math.min(group, this.groupLevels.length-1)];

        const len = minLen + (lvl * edgeWeight(t) * maxLen);
        this._drawBar(gx, gy, gx, gy - len, 0.95);
      }
    }

    // BOTTOM
    {
      const {N} = this.sides.bottom;
      for(let i=0;i<N;i++){
        const t = i/(N-1);
        const gx = x0 + t*w;
        const gy = y0 + h - inset;

        const group = this._groupForIndex(i, N);
        const lvl = this.groupLevels[Math.min(group, this.groupLevels.length-1)];

        const len = minLen + (lvl * edgeWeight(t) * maxLen);
        this._drawBar(gx, gy, gx, gy + len, 0.95);
      }
    }

    // LEFT
    {
      const {N} = this.sides.left;
      for(let i=0;i<N;i++){
        const t = i/(N-1);
        const gx = x0 + inset;
        const gy = y0 + t*h;

        const group = this._groupForIndex(i, N);
        const lvl = this.groupLevels[Math.min(group, this.groupLevels.length-1)];

        const len = minLen + (lvl * edgeWeight(t) * maxLen);
        this._drawBar(gx, gy, gx - len, gy, 0.95);
      }
    }

    // RIGHT
    {
      const {N} = this.sides.right;
      for(let i=0;i<N;i++){
        const t = i/(N-1);
        const gx = x0 + w - inset;
        const gy = y0 + t*h;

        const group = this._groupForIndex(i, N);
        const lvl = this.groupLevels[Math.min(group, this.groupLevels.length-1)];

        const len = minLen + (lvl * edgeWeight(t) * maxLen);
        this._drawBar(gx, gy, gx + len, gy, 0.95);
      }
    }

    // CORNER BLENDS (diagonal mini-fan)
    // These help make the “hairline aura” look continuous around corners
    {
      const fan = this.cornerBars.cornerFan; // number of diagonals per corner
      const angles = [];
      for(let k=0;k<fan;k++){
        // spread angles around diagonal direction
        // each corner has its own base diagonal angle
        const spread = (k/(fan-1) - 0.5) * (Math.PI/5);
        angles.push(spread);
      }

      // use the "outermost" group (slowest) but still reactive
      const cornerLvl = this.groupLevels[Math.min(this.groupLevels.length-1, 10)] || this.groupLevels[this.groupLevels.length-1];
      const cornerLen = 2 + cornerLvl * 22;

      function drawFan(self, cx, cy, baseAngle){
        for(let k=0;k<fan;k++){
          const a = baseAngle + angles[k];
          const dx = Math.cos(a);
          const dy = Math.sin(a);
          const l = cornerLen * (0.55 + 0.45*(k/(fan-1)));
          self._drawBar(cx, cy, cx + dx*l, cy + dy*l, 0.9);
        }
      }

      // TL: up-left
      drawFan(this, x0+inset, y0+inset, -3*Math.PI/4);
      // TR: up-right
      drawFan(this, x0+w-inset, y0+inset, -Math.PI/4);
      // BL: down-left
      drawFan(this, x0+inset, y0+h-inset, 3*Math.PI/4);
      // BR: down-right
      drawFan(this, x0+w-inset, y0+h-inset, Math.PI/4);
    }
  }
}
/* ========================================================== */

/* Create radiators */
const radOverlay = new Radiator(overlayWrap, "#00fff0");
const radYes = new Radiator(yesWrap, "#00fff0");
const radNo  = new Radiator(noWrap,  "#ff004c");

/* ===================== MAIN LOOP ===================== */
let raf = null;
let master = 0;

function loop(){
  const playing = analyser && currentAudioEl && !currentAudioEl.paused;

  // envelope smoothing similar to glow
  let target = 0;
  if(playing) target = getEnergy();

  // smoother master (extra)
  master = master * 0.84 + target * 0.16;

  // your glow stays (works great already)
  const glow = Math.round(22 + master * 110);
  questionEl.style.textShadow = `0 0 ${glow}px #00fff0`;

  // render bars only when audio is actually running
  const show = playing ? master : 0;
  radOverlay.render(show);
  radYes.render(show);
  radNo.render(show);

  raf = requestAnimationFrame(loop);
}

/* ===================== DODGE: NO stays red + moves (test) ===================== */
let noWrapFixed = false;
document.addEventListener('mousemove', (e) => {
  const r = noWrap.getBoundingClientRect();
  if(Math.hypot(e.clientX - r.left, e.clientY - r.top) < 120){

    if(!noWrapFixed){
      noWrapFixed = true;
      const rr = noWrap.getBoundingClientRect();
      noWrap.style.position = 'fixed';
      noWrap.style.left = rr.left + 'px';
      noWrap.style.top  = rr.top + 'px';
      noWrap.style.margin = '0';
    }

    const w = noWrap.offsetWidth;
    const h = noWrap.offsetHeight;
    const maxX = Math.max(0, innerWidth - w - 10);
    const maxY = Math.max(0, innerHeight - h - 10);

    noWrap.style.left = (Math.random() * maxX) + 'px';
    noWrap.style.top  = (Math.random() * maxY) + 'px';
  }
});

/* ===================== OVERLAY STEPS + AUDIO ===================== */
let overlayStep = 1;
let audioPrimed = false;

function setOverlayStep(step){
  overlayStep = step;
  tapOverlay.classList.remove('step1','step2','step3');
  tapOverlay.classList.add('step'+step);

  if(step===1) tapOverlayText.textContent = "Click if you really want to enter.";
  if(step===2) tapOverlayText.textContent = "You can still turn back.";
  if(step===3) tapOverlayText.textContent = "Enter at your own risk.";
}

function primeAudio(a){
  const prevMuted = a.muted;
  a.muted = true;
  const p = a.play();
  if(p && typeof p.then === 'function'){
    p.then(()=>{
      a.pause();
      try{ a.currentTime = 0; }catch(e){}
      a.muted = prevMuted;
    }).catch(()=>{ a.muted = prevMuted; });
  }else{
    a.pause();
    try{ a.currentTime = 0; }catch(e){}
    a.muted = prevMuted;
  }
}

setOverlayStep(1);

async function handleOverlayClick(){
  ensureAudio();
  try{ await audioCtx.resume(); }catch(e){}

  if(!raf) loop();

  // Start question audio at first click (and keep playing through overlay)
  if(!currentAudioEl){
    setActiveAudio(questionSound);
    try{ await questionSound.play(); } catch(e){ return; }

    // prime other audio so first YES/NO click doesn't lag
    if(!audioPrimed){
      audioPrimed = true;
      primeAudio(happySound);
      primeAudio(heartbeat);
    }
  }

  // Must click EACH overlay
  if(overlayStep < 3){
    setOverlayStep(overlayStep + 1);
    return;
  }

  tapOverlay.classList.add('hidden');
}

tapOverlay.addEventListener('pointerdown', handleOverlayClick, { passive:true });

/* ===================== YES / NO AUDIO SWITCHING (test) ===================== */
yes.addEventListener('click', async () => {
  // stop others, play happy
  questionSound.pause();
  heartbeat.pause();
  happySound.currentTime = 0;
  setActiveAudio(happySound);
  try{ await happySound.play(); }catch(e){}
});

no.addEventListener('click', async () => {
  // stop others, play heartbeat
  questionSound.pause();
  happySound.pause();
  heartbeat.currentTime = 0;
  setActiveAudio(heartbeat);
  try{ await heartbeat.play(); }catch(e){}
});

// Right click anywhere = "back" to question (quick test convenience)
document.addEventListener('contextmenu', async (e) => {
  e.preventDefault();
  happySound.pause();
  heartbeat.pause();
  setActiveAudio(questionSound);
  try{ await questionSound.play(); }catch(err){}
});
</script>
</body>
</html>
