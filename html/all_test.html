<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ALL Radiator Test (Curved Perimeter)</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{
    height:100vh; overflow:hidden;
    font-family:'Orbitron',sans-serif;
    background:radial-gradient(circle at top,#0e1a2f,#05070c);
    color:#00fff0;
  }
  .background{
    position:fixed;inset:0;
    background:
      repeating-linear-gradient(0deg,rgba(0,255,255,.06) 0 1px,transparent 1px 36px),
      repeating-linear-gradient(90deg,rgba(0,255,255,.06) 0 1px,transparent 1px 36px);
    animation:grid 12s linear infinite;
    z-index:0;
  }
  @keyframes grid{to{background-position:0 36px,36px 0}}

  .ui{
    position:relative; z-index:2;
    height:100%;
    display:flex; flex-direction:column;
    justify-content:center; align-items:center;
    gap:18px;
  }

  h2{
    font-size:2.3rem;
    text-shadow:0 0 25px #00fff0;
    animation:floatQ 3s ease-in-out infinite;
  }
  @keyframes floatQ{50%{transform:translateY(-10px)}}

  .wrap{ position:relative; display:inline-block; }

  button{
    padding:16px 56px;
    font-family:'Orbitron';
    font-size:1.05rem;
    border-radius:18px;
    border:none;
    cursor:pointer;
    background:linear-gradient(135deg,#00fff0,#00b3ff);
    color:#000;
    box-shadow:0 0 40px rgba(0,255,240,.35);
  }

  .tapOverlay{
    position:fixed; inset:0;
    background:#000;
    display:flex; align-items:center; justify-content:center;
    z-index:999;
    cursor:pointer;
  }
  .tapOverlay.hidden{display:none}
  .tapOverlay span{
    padding:14px 18px;
    border:1px solid #00fff0;
    box-shadow:0 0 30px rgba(0,255,240,.55);
    border-radius:18px;
    text-shadow:0 0 18px #00fff0;
    color:#00fff0;
    background:rgba(0,0,0,.15);
  }

  canvas{
    position:fixed; inset:0;
    pointer-events:none;
    z-index:3;
  }

  .hint{opacity:.7;font-size:.9rem}
</style>
</head>
<body>
<div class="background"></div>

<div class="ui">
  <h2 id="q">Will you be my valentine?</h2>
  <div class="wrap" id="pillWrap">
    <button id="pillBtn">YOU CAN STILL TURN BACK</button>
  </div>
  <div class="hint">ALL-sides test (curved perimeter — corners should feel seamless)</div>
</div>

<div class="tapOverlay" id="tap">
  <span>Click to start audio + bars</span>
</div>

<audio id="questionSound" src="question.mp3" loop></audio>
<canvas id="c"></canvas>

<script>
const qEl = document.getElementById('q');
const wrap = document.getElementById('pillWrap');
const btn  = document.getElementById('pillBtn');
const tap  = document.getElementById('tap');
const audioEl = document.getElementById('questionSound');
audioEl.volume = 0.6;

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dpr = Math.max(1, window.devicePixelRatio || 1);

function resize(){
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width  = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', resize);
resize();

/* ===================== AUDIO ===================== */
let audioCtx, analyser, dataArr, srcNode;
function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  dataArr = new Uint8Array(analyser.frequencyBinCount);

  srcNode = audioCtx.createMediaElementSource(audioEl);
  srcNode.connect(analyser);
  analyser.connect(audioCtx.destination);
}
function energy(){
  analyser.getByteFrequencyData(dataArr);
  let sum=0,n=0;
  for(let i=18;i<=220;i++){ sum+=dataArr[i]; n++; }
  let v=(sum/n)/255;
  return v*v;
}

/* ===================== HISTORY (FOR VISIBLE DELAYS) ===================== */
const HIST=240;
const hist=new Float32Array(HIST);
let hPos=0;
function push(v){ hist[hPos]=v; hPos=(hPos+1)%HIST; }
function get(delayFrames){
  let i=hPos-1-delayFrames;
  while(i<0) i+=HIST;
  return hist[i%HIST];
}

/* ===================== UTIL ===================== */
function noise(i, salt){
  const x = Math.sin((i+salt) * 127.1) * 43758.5453123;
  return x - Math.floor(x);
}
function edgeWeight(t){
  return 0.25 + 0.75*Math.sin(Math.PI*t);
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

/* ===================== CURVED PERIMETER SAMPLING ===================== */
/*
  Build points along a rounded-rect perimeter:
  - includes corner arcs naturally
  - each point has outward normal
  Then classify points into regions (top/right/bottom/left) by normal direction
  and apply your mirror + delay logic *per region*.
*/
let cacheKey = "";
let points = []; // {x,y,nx,ny, region, tInRegion, idxInRegion}
let regionIndices = { top:[], right:[], bottom:[], left:[] };
let levels = []; // per point smoothing state

function buildPerimeter(rect){
  const style = getComputedStyle(btn);
  let r = parseFloat(style.borderRadius) || 18;
  r = Math.max(0, Math.min(r, rect.width/2, rect.height/2));

  // density (your “2 in place of 1”)
  const spacing = 3.5;

  // perimeter lengths
  const w = rect.width, h = rect.height;
  const straightTop = Math.max(0, w - 2*r);
  const straightSide = Math.max(0, h - 2*r);
  const arcLen = 0.5*Math.PI*r; // quarter circle length
  const perimeter =
    straightTop*2 + straightSide*2 + arcLen*4;

  const count = Math.max(140, Math.floor(perimeter / spacing));
  points = [];
  regionIndices = { top:[], right:[], bottom:[], left:[] };
  levels = new Array(count).fill(0);

  // helper to push point
  function addPoint(x,y,nx,ny){
    // classify by normal (this makes corners blend seamlessly)
    let region = "top";
    if(Math.abs(nx) > Math.abs(ny)){
      region = (nx > 0) ? "right" : "left";
    }else{
      region = (ny > 0) ? "bottom" : "top";
    }

    const idx = points.length;
    points.push({x,y,nx,ny, region, tInRegion:0, idxInRegion:0});
    regionIndices[region].push(idx);
  }

  // walk along perimeter (clockwise), starting at top-left straight start (after corner)
  let s = 0;
  for(let i=0;i<count;i++){
    const u = (i/(count)) * perimeter; // distance along perimeter

    const x0 = rect.left;
    const y0 = rect.top;

    // segment boundaries (clockwise):
    // 1) top straight (left->right)
    // 2) top-right arc
    // 3) right straight (top->bottom)
    // 4) bottom-right arc
    // 5) bottom straight (right->left)
    // 6) bottom-left arc
    // 7) left straight (bottom->top)
    // 8) top-left arc

    let d = u;

    // 1) top straight
    if(d <= straightTop){
      const x = x0 + r + d;
      const y = y0;
      addPoint(x,y, 0,-1);
      continue;
    }
    d -= straightTop;

    // 2) top-right arc (theta -90 -> 0)
    if(d <= arcLen){
      const t = d/arcLen;
      const theta = (-Math.PI/2) + t*(Math.PI/2);
      const cx = x0 + w - r;
      const cy = y0 + r;
      const x = cx + r*Math.cos(theta);
      const y = cy + r*Math.sin(theta);
      addPoint(x,y, Math.cos(theta), Math.sin(theta));
      continue;
    }
    d -= arcLen;

    // 3) right straight
    if(d <= straightSide){
      const x = x0 + w;
      const y = y0 + r + d;
      addPoint(x,y, 1,0);
      continue;
    }
    d -= straightSide;

    // 4) bottom-right arc (theta 0 -> 90)
    if(d <= arcLen){
      const t = d/arcLen;
      const theta = 0 + t*(Math.PI/2);
      const cx = x0 + w - r;
      const cy = y0 + h - r;
      const x = cx + r*Math.cos(theta);
      const y = cy + r*Math.sin(theta);
      addPoint(x,y, Math.cos(theta), Math.sin(theta));
      continue;
    }
    d -= arcLen;

    // 5) bottom straight (right->left)
    if(d <= straightTop){
      const x = x0 + w - r - d;
      const y = y0 + h;
      addPoint(x,y, 0,1);
      continue;
    }
    d -= straightTop;

    // 6) bottom-left arc (theta 90 -> 180)
    if(d <= arcLen){
      const t = d/arcLen;
      const theta = (Math.PI/2) + t*(Math.PI/2);
      const cx = x0 + r;
      const cy = y0 + h - r;
      const x = cx + r*Math.cos(theta);
      const y = cy + r*Math.sin(theta);
      addPoint(x,y, Math.cos(theta), Math.sin(theta));
      continue;
    }
    d -= arcLen;

    // 7) left straight (bottom->top)
    if(d <= straightSide){
      const x = x0;
      const y = y0 + h - r - d;
      addPoint(x,y, -1,0);
      continue;
    }
    d -= straightSide;

    // 8) top-left arc (theta 180 -> 270)
    {
      const t = (arcLen === 0) ? 0 : (d/arcLen);
      const theta = Math.PI + t*(Math.PI/2);
      const cx = x0 + r;
      const cy = y0 + r;
      const x = cx + r*Math.cos(theta);
      const y = cy + r*Math.sin(theta);
      addPoint(x,y, Math.cos(theta), Math.sin(theta));
    }
  }

  // compute idxInRegion + tInRegion
  for(const region of ["top","right","bottom","left"]){
    const idxs = regionIndices[region];
    const N = idxs.length;
    for(let j=0;j<N;j++){
      const p = points[idxs[j]];
      p.idxInRegion = j;
      p.tInRegion = (N<=1) ? 0 : j/(N-1);
    }
  }
}

function ensurePerimeter(){
  const r = wrap.getBoundingClientRect();
  const style = getComputedStyle(btn);
  const br = style.borderRadius || "";
  const key = `${Math.round(r.left)}|${Math.round(r.top)}|${Math.round(r.width)}|${Math.round(r.height)}|${br}|${innerWidth}|${innerHeight}`;
  if(key !== cacheKey){
    cacheKey = key;
    buildPerimeter(r);
  }
}

/* ===================== DRAW ===================== */
function smooth(cur, target){
  return (target > cur)
    ? cur + (target-cur)*0.55
    : cur + (target-cur)*0.18;
}

function drawAll(master){
  ensurePerimeter();

  ctx.lineWidth = 1;
  ctx.strokeStyle = '#00fff0';
  ctx.shadowColor = '#00fff0';
  ctx.shadowBlur = 10;

  const minLen = 2.5;
  const maxLen = 46;

  // For each region, compute center index for mirror symmetry + delay
  const regionInfo = {};
  for(const region of ["top","right","bottom","left"]){
    const idxs = regionIndices[region];
    regionInfo[region] = {
      idxs,
      N: idxs.length,
      center: (idxs.length-1)/2
    };
  }

  // Draw all points
  for(let i=0;i<points.length;i++){
    const p = points[i];
    const info = regionInfo[p.region];
    if(!info || info.N < 2) continue;

    // mirror symmetry within region
    const dist = Math.abs(p.idxInRegion - info.center);
    const delay = Math.min(180, Math.floor(dist)*6);

    // delayed energy (the thing that makes it NOT all move together)
    const e = get(delay);

    // weight near middle of region (helps look like TOP version)
    const w = edgeWeight(p.tInRegion);

    // small per-point variation so it feels alive but still grouped
    const n = (noise(i, 37)-0.5) * 0.18;

    const target = clamp01(e + n);
    levels[i] = smooth(levels[i], target);

    const L = minLen + levels[i]*w*maxLen;

    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p.x + p.nx*L, p.y + p.ny*L);
    ctx.stroke();
  }

  ctx.shadowBlur = 0;
}

/* ===================== LOOP ===================== */
let raf = null;
let master = 0;

function loop(){
  ctx.clearRect(0,0,innerWidth,innerHeight);

  let e = 0;
  if(!audioEl.paused) e = energy();

  master = master*0.86 + e*0.14;
  push(e);

  const glow = Math.round(22 + master*110);
  qEl.style.textShadow = `0 0 ${glow}px #00fff0`;

  if(!audioEl.paused) drawAll(master);

  raf = requestAnimationFrame(loop);
}

/* ===================== START ===================== */
tap.addEventListener('pointerdown', async ()=>{
  ensureAudio();
  try{ await audioCtx.resume(); }catch(e){}
  try{ await audioEl.play(); }catch(e){ return; }
  tap.classList.add('hidden');
  if(!raf) loop();
},{passive:true});
</script>
</body>
</html>
